// ---------- string helpers ----------
@function s_str($v) { @return #{$v}; }
@function s_starts_with($s, $prefix) { @return string.index($s, $prefix) == 1; }
@function s_after($s, $prefix) { @return string.slice($s, string.length($prefix) + 1); }
@function s_contains($s, $needle) { @return string.index($s, $needle) != null; }
@function s_first_dash($s) { @return string.index($s, "-"); }

// join path + segment with "-" (skip empty bits)
@function s_join($a, $b) {
  @if ($a == null or $a == "") { @return $b; }
  @if ($b == null or $b == "") { @return $a; }
  @return $a + "-" + $b;
}

// remove trailing "-default" (e.g. "theme-default" -> "theme")
@function s_trim_default($name) {
  @if $name == null { @return $name; }
  $suffix: "-default";
  $i: string.index($name, $suffix);
  @if $i != null and $i == string.length($name) - string.length($suffix) + 1 {
    @return string.slice($name, 1, string.length($name) - string.length($suffix));
  }
  @return $name;
}

// ---------- set/map helpers ----------
@function s_set_put($set, $key) { @return map.merge($set, ( $key: true )); }
@function s_set_has($set, $key) { @return map.has-key($set, $key); }

@function s_is_scalar($v) {
  $t: meta.type-of($v);
  @return $v != null and $v != "" and $t != 'map';
}

@function s_has_raw_theme_token($name) { @return s_contains($name, "--"); }

// ---------- global state ----------
// These are intentionally simple: one pass collects everything.
$g_base: () !default;        // name -> scalar value (includes defaults)
$g_root: () !default;        // set(name) that must be promoted to :root
$g_themes: () !default;      // theme -> (name -> scalar value)

// Known theme keys must be provided by wrapper before including this file:
// $s_theme_keys: ('dark', 'light', ...)

// ---------- recursive collector ----------
@mixin s_collect($mapVal, $path: "", $promote: false) {
  @each $rawKey, $val in $mapVal {
    $k: s_str($rawKey);

    // Theme override at any depth: --dark-<suffix> (suffix can be "default", "50", "foo", etc.)
    @if s_starts_with($k, "--") and s_contains($k, "-") and meta.type-of($val) != 'map' {
      $tmp: s_after($k, "--");            // e.g. "dark-default", "dark-5"
      $dash: s_first_dash($tmp);
      @if $dash != null {
        $theme: string.slice($tmp, 1, $dash - 1);
        $rest: string.slice($tmp, $dash + 1);
        $namePart: if($rest == "default", "", $rest);
        $varName: s_trim_default(s_join($path, $namePart)); // default → base name

        @if list.index($s_theme_keys, $theme) {
          // record theme override under the cleaned logical name
          $bucket: map.get($g_themes, $theme);
          @if $bucket == null { $bucket: (); }
          $bucket: map.merge($bucket, ( $varName: $val ));
          $g_themes: map.merge($g_themes, ( $theme: $bucket )) !global;

          // any override means the base must be present in :root
          $g_root: s_set_put($g_root, $varName) !global;

          // ensure a base exists (collector will also add if a default leaf exists)
          @if not map.has-key($g_base, $varName) {
            $g_base: map.merge($g_base, ( $varName: $val )) !global;
          }
        } @else {
          // unknown theme: keep the raw name ONLY in base so @theme can expose it literally
          // (never promote to :root)
          $kept: s_join($path, $k); // e.g. "chart---weird-5"
          @if not map.has-key($g_base, $kept) {
            $g_base: map.merge($g_base, ( $kept: $val )) !global;
          }
        }
      }
      @continue;
    }

    // segment-level "#" forces promotion for this subtree
    $segPromote: false;
    @if s_starts_with($k, "#") {
      $segPromote: true;
      $k: s_after($k, "#");
    }

    // Nested map → recurse. "default" means "don’t extend the path".
    @if meta.type-of($val) == 'map' {
      $nextPath: if($k == "default", $path, s_join($path, $k));
      @include s_collect($val, $nextPath, $promote or $segPromote);
      @continue;
    }

    // Leaf scalar
    $leafName: if($k == "default", $path, s_join($path, $k));

    // store base literal for this logical name (handles "default" properly)
    @if $leafName != null and $leafName != "" and s_is_scalar($val) {
      $g_base: map.merge($g_base, ( $leafName: $val )) !global;
      // promote to :root if any ancestor requested promotion
      @if $promote or $segPromote {
        $g_root: s_set_put($g_root, $leafName) !global;
      }
    }
  }
}

// ---------- cleaning ----------
@mixin s_clean() {
  // Drop any non‑scalars and any names that still contain raw theme tokens.
  $__base: ();
  @each $name, $value in $g_base {
    @if s_is_scalar($value) and not s_has_raw_theme_token($name) {
      $__base: map.merge($__base, ($name: $value));
    }
  }
  $g_base: $__base !global;

  $__root: ();
  @each $name, $flag in $g_root {
    @if not s_has_raw_theme_token($name) and map.has-key($g_base, $name) {
      $__root: map.merge($__root, ($name: true));
    }
  }
  $g_root: $__root !global;

  // theme maps keep only scalars; their names have already been normalized
  $__themes: ();
  @each $theme, $vars in $g_themes {
    $__t: ();
    @each $n, $v in $vars {
      @if s_is_scalar($v) and not s_has_raw_theme_token($n) {
        $__t:map.merge($__t, ($n: $v));
      }
    }
    $__themes: map.merge($__themes, ($theme: $__t));
  }
  $g_themes: $__themes !global;
}

// ---------- emit ----------
@mixin s_emit() {
  // 1) :root — only promoted names
  :root {
    @each $name, $flag in $g_root {
      --#{$name}: #{map.get($g_base, $name)};
    }
  }

  // 2) Theme classes
  @each $theme, $vars in $g_themes {
    .#{$theme} {
      @each $name, $value in $vars {
        --#{$name}: #{$value};
      }
    }
  }

  // 3) @theme — union of base names and themed names
  // Build the union of names we must expose
  $__all: $g_base;
  @each $theme, $vars in $g_themes {
    @each $n, $v in $vars {
      @if not map.has-key($__all, $n) {
        // Prefer base if present; else fall back to the theme value so something exists
        $__all: map.merge($__all, ($n: $v));
      }
    }
  }

  @theme {
    @each $name, $value in $__all {
      @if map.has-key($g_root, $name) {
        --color-#{$name}: var(--#{$name});
      } @else {
        --color-#{$name}: #{$value};
      }
    }
  }
}

// ---------- public entry ----------
@mixin s_walk_colors($rootMap) {
  // reset
  $g_base: () !global;
  $g_root: () !global;
  $g_themes: () !global;

  // collect deep
  @include s_collect($rootMap, "", false);

  // If any name has a known theme override, ensure it is promoted to :root
  @each $theme, $vars in $g_themes {
    @each $n, $v in $vars {
      $g_root: s_set_put($g_root, $n) !global;
    }
  }

  // clean and emit
  @include s_clean();
  @include s_emit();
}